from typing import List
from langchain.prompts import PromptTemplate
from langchain.chains import LLMChain
from langchain_community.chat_models import ChatOllama
from langchain.memory import ConversationBufferMemory
import re
from pptx import Presentation
from pptx.util import Pt
from pptx.dml.color import RGBColor
from io import BytesIO
from enum import Enum

class SlideStyle(Enum):
    PROFESSIONAL = "professional"
    ACADEMIC = "academic"
    CLINICAL = "clinical"

class SlideAgent:
    def __init__(self, model_name: str = "neural-chat"):
        self.llm = ChatOllama(model=model_name, temperature=0.3)
        self.memory = ConversationBufferMemory(memory_key="chat_history")
        self._initialize_prompts()

    def _initialize_prompts(self):
        self.structure_prompt = PromptTemplate.from_template(
            """You are a medical slide content organizer. Divide the input into exactly {num_sections} slide sections.
Style: {style}

Instructions:
- Each section has:
   • A short heading (Title Case)
   • 3–5 concise bullet points (≤ 8 words)
   • Add evidence levels [L1-5] and [CR] markers if applicable
- Format strictly like this:
[SECTION] Heading
- Point 1 [L2]
- Point 2 [CR]
- Point 3

Content:
{content}

Output:"""
        )

        self.refine_prompt = PromptTemplate.from_template(
            """Refine the following slide content for a {style} medical audience.
Instructions:
- Ensure clarity and clinical accuracy
- Improve structure and formatting
- Keep total sections exactly 5

Slides:
{current_slides}

Refined:"""
        )

    def create_structured_content(self, content: str, num_sections: int = 5, style: SlideStyle = SlideStyle.CLINICAL) -> str:
        structure_chain = LLMChain(llm=self.llm, prompt=self.structure_prompt)
        raw_output = structure_chain.run({
            'content': content,
            'num_sections': num_sections,
            'style': style.value
        })

        # Force split and check number of sections
        sections = re.split(r'\[SECTION\]\s+', raw_output.strip())
        sections = [s for s in sections if s.strip()]
        
        if len(sections) != num_sections:
            # Add placeholder slides if missing
            while len(sections) < num_sections:
                sections.append(f"Extra Slide {len(sections)+1}\n- Placeholder point [CR]")
            sections = sections[:num_sections]  # Ensure max 5

            raw_output = "\n\n".join(f"[SECTION] {s.strip()}" for s in sections)

        refine_chain = LLMChain(llm=self.llm, prompt=self.refine_prompt)
        refined_output = refine_chain.run({
            'current_slides': raw_output,
            'style': style.value
        })

        return self._clean_output(refined_output)


    def _clean_output(self, text: str) -> str:
        # Normalize and clean
        text = re.sub(r'\[SECTION\]\s*', '[SECTION] ', text, flags=re.IGNORECASE)
        text = text.strip()
        return text

    def create_presentation(self, structured_content: str, title: str = "Medical Presentation") -> BytesIO:
        prs = Presentation()

        # Title Slide
        slide = prs.slides.add_slide(prs.slide_layouts[0])
        slide.shapes.title.text = title
        slide.placeholders[1].text = "Generated by CellBot Medical Assistant"

        # Parse exactly 5 sections
        sections = re.split(r'\[SECTION\]\s+', structured_content.strip())[1:]
        sections = sections[:5] + ["Extra Slide\n- Placeholder point"] * (5 - len(sections))

        for section in sections:
            lines = section.strip().split('\n')
            if not lines:
                continue
            heading = lines[0].strip()
            bullets = [line.strip() for line in lines[1:] if line.strip().startswith('-')]

            slide = prs.slides.add_slide(prs.slide_layouts[1])
            slide.shapes.title.text = heading
            text_frame = slide.placeholders[1].text_frame
            text_frame.clear()

            for bullet in bullets:
                clean = bullet[1:].strip()
                p = text_frame.add_paragraph()
                p.text = clean
                p.level = 0
                p.font.size = Pt(18)

                # Highlight markers
                if '[CR]' in clean:
                    run = p.add_run()
                    run.text = " [CR]"
                    run.font.color.rgb = RGBColor(0, 102, 204)

                level_match = re.search(r'\[L\d\]', clean)
                if level_match:
                    run = p.add_run()
                    run.text = " " + level_match.group()
                    run.font.color.rgb = RGBColor(204, 0, 0)

        output = BytesIO()
        prs.save(output)
        output.seek(0)
        return output
